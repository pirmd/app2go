' -----------------------------------------------------------------------------
'  DESCRIPTION: library to build portable environement for windows application
'      CREATED: 2008.08.08 / REVISION: 2016.05.12 - 16:32
' -----------------------------------------------------------------------------

On Error Goto 0

Set WMIService = GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2")
Set WshShell   = CreateObject("WScript.Shell")
Set FSO        = CreateObject("Scripting.FileSystemObject")

' =============================================================================
'  DESCRIPTION: determine and make available useful vars
' =============================================================================

LauncherDrive  = FSO.GetDriveName(WScript.ScriptFullName)
LauncherFolder = FSO.GetParentFolderName(WScript.ScriptFullName)

MyDocsOnHost  = WshShell.SpecialFolders("MyDocuments")
DesktopOnHost = WshShell.SpecialFolders("Desktop")
SendToOnHost  = WshShell.SpecialFolders("SendTo")

AppdirOnHost = WshShell.ExpandEnvironmentStrings("%APPDATA%")
TempOnHost   = WshShell.ExpandEnvironmentStrings("%TEMP%")
HostName     = WshShell.ExpandEnvironmentStrings("%COMPUTERNAME%")

HKCU="HKEY_CURRENT_USER\"
HKCU_CLASSES=HKCU&"SOFTWARE\CLASSES\"


' =============================================================================
'  DESCRIPTION: core app2go functions
' =============================================================================

'---+ Easy Access to Log facilities from outside -------------------------------
Set MyLauncher = New Launcher
Set CommonResources = New ShareResource

'---+ Flags/Options -----------------------------------------------------------
FORCE_CLEAN = False

' ------------------------------------------------------------------------------
'         NAME: AddTaskXXX
'  DESCRIPTION: Add a launcher task for XXX 'run level'.
'      PARAM 1: task to run
'      PARAM 2: task arguments as Array()
' ------------------------------------------------------------------------------
Public Sub AddTaskStart(cmd, arg_array)
    MyLauncher.AddTaskStart cmd, arg_array
End Sub

Public Sub AddTaskStop(cmd, arg_array)
    MyLauncher.AddTaskStop cmd, arg_array
End Sub

Public Sub AddTaskOnExit(cmd, arg_array)
    MyLauncher.AddTaskOnExit cmd, arg_array
End Sub
' End AddTaskXXX --------------------------------------------------------------

' ------------------------------------------------------------------------------
'         NAME: TaskError
'  DESCRIPTION: Raise an Error during a task execution
'      PARAM 1: Error description
' ------------------------------------------------------------------------------
Public Sub TaskError(msg)
    MyLauncher.TaskError msg
End Sub ' End TaskError --------------------------------------------------------

' ------------------------------------------------------------------------------
'         NAME: Acquire/ReleaseResource
'  DESCRIPTION: Acquire/Release a shared resource
'      PARAM 1: array with resource ID
'       OUTPUT: True if acquisition/release is done for the first/last time
' ------------------------------------------------------------------------------
Public Function AcquireResource(resID)
    AcquireResource = CommonResources.Acquire(resID)
End Function

Public Function ReleaseResource(resID)
    ReleaseResource = CommonResources.Release(resID)
End Function
' End Acquire/ReleaseResource --------------------------------------------------

' ------------------------------------------------------------------------------
'         NAME: Set/GetResourceParam
'  DESCRIPTION: Set/Get a param of a shared resource
'      PARAM 1: array with resource ID
' ------------------------------------------------------------------------------
Public Sub SetResourceParam(resID, paramValue)
    CommonResources.SharedParam(resID) = paramValue
End Sub

Public Function GetResourceParam(resID)
    GetResourceParam = CommonResources.SharedParam(resID)
End Function
' End Set/getResourceParam -----------------------------------------------------

' ------------------------------------------------------------------------------
'         NAME: StartLauncher
'  DESCRIPTION: Start launcher
'      PARAM 1: Path to the script to start
'      PARAM 2: Additional arguments pass to the scripts
' ------------------------------------------------------------------------------
Public Sub StartLauncher(app2goScript, ScriptArguments)
    LogVerbose "Start "&app2goScript&" with arguments: "&ScriptArguments
    CommandLineArguments = ScriptArguments
    LoadScript app2goScript
    MyLauncher.StartLauncher()
End Sub 'StartLauncher ---------------------------------------------------------




' -----------------------------------------------------------------------------
'          CLASS: Launcher
'    DESCRIPTION: base class for a portable launcher which in fact
'                 aims at mimicing a try...finaly class
'                 I would love to get rid of it if someone has a better idea to
'                 ensure TodoClean/ToDoOnExit actions can be launched whatever happen
' PUBLIC METHODS:
'     . AddTask       -- Add a Task
'     . AddTaskClean  -- Add a Task to clean environement after tasks have been executed
'     . AddTaskOnExit -- Add a Task to perform before exiting launcher (and after cleaning)
'     . StartLauncher -- Execute the job in the queue.
'                        Take StopOnError flag as aparameter to determine if we
'                        stop or not the execution if an error appears
'     . StopLauncher  -- Stop the launcher and cleanly exit (execute the tasks
'                        in the TodoOnExit queue)
'     . Error         -- Handle errors during the execution of tasks
' TODO: Show in debug level the content of the queues
' -----------------------------------------------------------------------------
Class Launcher
    Private ToDoStart
    Private ToDoStop
    Private ToDoOnExit
    Private BreakOnError

    Private Sub Class_initialize()
        Set ToDoStart = New TaskQueue
        Set ToDoStop = New TaskQueue
        Set ToDoOnExit = New TaskQueue
        BreakOnError = True
    End Sub

    Public Sub StartLauncher()
        LogVerbose "Start launcher"
        ToDoStart.start_FIFO(BreakOnError)
    End Sub

    Private Function build_task_cmd(cmd, arg_array)
        arg = Chr(34) & Join(arg_array, """,""") & Chr(34)
        build_task_cmd = Join(Array(cmd, arg), " ")
    End Function

    Public Sub AddTaskStart(cmd, arg_array)
        ToDoStart.Add(build_task_cmd(cmd&"_start", arg_array))
    End Sub

    Public Sub AddTaskOnExit(cmd, arg_array)
        ToDoOnExit.Add(build_task_cmd(cmd&"_exit", arg_array))
    End Sub

    Public Sub AddTaskStop(cmd, arg_array)
        ToDoStop.Add(build_task_cmd(cmd&"_stop", arg_array))
    End Sub

    Public Sub TaskError(Msg)
        If BreakOnError Then
            LogError Msg
            WScript.Quit(10)
        Else
            LogWarning Msg
            Err.Clear
        End If
    End Sub

    Private Sub Class_Terminate()
        LogVerbose "Stopping launcher"
        BreakOnError = False 'try to execute as much tasks as possible on exit
        ToDoStop.start_LIFO(BreakOnError)
        ToDoOnExit.start_FIFO(BreakOnError)
    End Sub
End Class 'Launcher -----------------------------------------------------------

' ------------------------------------------------------------------------------
'          CLASS: TaskQueue
'    DESCRIPTION: Poor-man task queue manager
' PUBLIC METHODS:
'     . Reset    -- clear queue
'     . Add      -- allow to add task to a queue
'     . Run_FIFO -- exec the tasks in the queue in FIFO mode
'     . Run_LIFO -- exec the tasks in the queue in LIFO mode
' -----------------------------------------------------------------------------
Class TaskQueue
  Private TaskList
  Private LastTaskIndex

  Private Sub Class_Initialize()
    Redim TaskList(20)
    LastTaskIndex = -1
  End Sub

  Public Sub Add(task)
    If LastTaskIndex=UBound(TaskList) then
      Redim Preserve TaskList(LastTaskIndex + 1)
    End If
    LastTaskIndex = LastTaskIndex + 1
    TaskList(LastTaskIndex) = task
  End Sub

 Private Sub execute_task(index)
     LogDebug "Execute task "&index&": "&TaskList(index)
     Execute TaskList(index)
 End Sub

 Public Sub start_LIFO(BreakOnError)
     If Not BreakOnError Then
         On Error Resume Next
     End If
     For task_index = LastTaskIndex To 0 Step -1
         execute_task(task_index)
     Next
     On Error Goto 0
 End Sub

 Public Sub start_FIFO(BreakOnError)
     If Not BreakOnError Then
         On Error Resume Next
     End If
     For task_index = 0 To LastTaskIndex
         execute_task(task_index)
     Next
     On Error Goto 0
 End Sub
End Class 'TaskQueue ----------------------------------------------------------

' -----------------------------------------------------------------------------
'          CLASS: ShareResource
'    DESCRIPTION: Poor-man semaphore-like to work with launcher share resources
'                 in a gentle manner (don't clean a resources used by someone else)
'     LIMITATION: Race conditions are not excluded when trying to read or update
'                 a shared environment variable but shoul dbe acceptable in our
'                 use case.
'                 hashcode use to compute environment var name according to
'                 resource name is weak but shoul dbe acceptable in our use case
' PUBLIC METHODS:
'     . Acquire  -- Acquire a resource. Return True if we are the first to
'                   acquire it, false otherwise
'     . Release  -- Release a resource. Return True if we are the last owner,
'                   False otherwise
'     . SetSharedParam -- define a parameter shared between launchers
'     . GetSharedParam -- retrieve a parameter shared between launchers
' TODO: Better FORCE_CLEAN Interface
' TODO: limit calls to resName
' -----------------------------------------------------------------------------
Class ShareResource
    Private semaphCollec
    Private paramCollec

    Private Sub Class_initialize()
        Set semaphCollec = WshShell.Environment("Volatile")
        Set paramCollec =  WshShell.Environment("Volatile")
    End Sub

    Private Property Get Semaphore(resID)
        varValue = semaphCollec(resName(resID))
        If varValue = "" Then 'First time we ask for this resource
            Semaphore = 0
        Else
            Semaphore = cint(varValue)
        End If
    End Property

    Private Property Let Semaphore(resID, varValue)
        varName = resName(resID)
        If varValue = 0 Then 'no more used
            LogDebug "Delete semaphore for shared resource "&resID(0)
            semaphCollec.Remove varName
            DelSharedParam(varName)
        Else
            semaphCollec(varName) = cstr(varValue)
        End If
    End Property

    Private Function resName(resID)
        resName = HashCode(Join(resID, "::"))
    End Function

    Private Function resNameParam(varName)
        resNameParam = varName&"_PARAM"
    End Function

    Private Function HashCode(myStr)
    ' F(n)=((127 & F(n-1) + string(n)) Mod 16908799
        hash = 0 : i =0
        while (i < Len(myStr))
            i = i + 1
            hash = ((127 * hash) + Asc(Mid(myStr,i,1))) Mod 16908799
        wend
        HashCode = hash
    End Function

    Public Function Acquire(resID)
        If FORCE_CLEAN Then
            LogDebug "Force resource acquisition for "& resID(0)
            Acquire = True
            Semaphore(resID) = 1
        Else
            varValue = Semaphore(resID)
            LogDebug "Acquire resource for "&resID(0)&" (shared with "&varValue&" launcher(s))"
            Semaphore(resID) = varValue+1
            Acquire = ( varValue = 0 )
        End If
    End Function

    Public Function Release(resID)
        If FORCE_CLEAN Then
            LogDebug "Force release of resource for "&resID(0)
            Semaphore(resID) = 0
            Release = True
        Else
            varValue = Semaphore(resID)
            LogDebug "Release resource for "&resID(0)&" (shared with "&varValue&" launcher(s))"
            Semaphore(resID) = varValue-1
            Release = (varValue = 1)
        End If
    End Function

    Public Property Let SharedParam(resID, ParamValue)
        varName = resNameParam(resID)
        paramCollec(VarName) = ParamValue
        LogDebug "Set shared parameter for "&resID(0)&" to "&ParamValue
    End Property

    Public Property Get SharedParam(resID)
        varName = resNameParam(resID)
        SharedParam = paramCollec(varName)
        LogDebug "Get shared parameter for "&resID(0)&" ("&SharedParam&")"
    End Property

    Private Sub DelSharedParam(varName)
        paramName = resNameParam(varName)
        If paramCollec(paramName) <> "" Then
            LogDebug "Delete shared parameter for "&resID(0)
            paramCollec.Remove paramName
        End If
    End Sub
End Class 'ShareResource ------------------------------------------------------

' =============================================================================
'  DESCRIPTION: vbs library that provide basic log facilities
' =============================================================================
' TODO: Log to file

'---+ Nice Constants ----------------------------------------------------------
Const LOG_CRITICAL = 0
Const LOG_ERROR = 10
Const LOG_WARNING = 20
Const LOG_INFO = 30
Const LOG_VERBOSE = 40
Const LOG_DEBUG = 50

'---+ Easy Access to Log facilities from outside -------------------------------
Set MyLogger = New Logger

' ----------------------------------------------------------------------------
'        NAME: LogXXXX
' DESCRIPTION: Send a log message of level XXXX
' ----------------------------------------------------------------------------
Public Sub LogDebug(msg)
    MyLogger.debug msg
End Sub

Public Sub LogError(msg)
    MyLogger.error msg
End Sub

Public Sub LogVerbose(msg)
    MyLogger.verbose msg
End Sub

Public Sub LogInfo(msg)
    MyLogger.info msg
End Sub

Public Sub LogWarning(msg)
    MyLogger.warning msg
End Sub
' End Of functions LogXXXXX ---------------------------------------------------

' ----------------------------------------------------------------------------
'        NAME: Die
' DESCRIPTION: Quit program immediatly with an error
'     PARAM 1: error message
' ----------------------------------------------------------------------------
Private Sub Die(Msg)
    LogError Msg
    WScript.Quit(-1)
End Sub 'Die -----------------------------------------------------------------


' ------------------------------------------------------------------------------
'        NAME: ShowXXXXMsg
' DESCRIPTION: Show messages up to level XXXX
' ------------------------------------------------------------------------------
Public Sub ShowDebugMsg()
    MyLogger.LogLvl = LOG_DEBUG
End Sub

Public Sub ShowErrorMsg()
    MyLogger.LogLvl = LOG_ERROR
End Sub

Public Sub ShowVerboseMsg()
    MyLogger.LogLvl = LOG_VERBOSE
End Sub

Public Sub ShowInfoMsg()
    MyLogger.LogLvl = LOG_INFO
End Sub

Public Sub ShowWarningMsg()
    MyLogger.LogLvl = LOG_WARNING
End Sub
'End of functions ShowXXXXMsg --------------------------------------------------


' -----------------------------------------------------------------------------
'          CLASS: Logger
'    DESCRIPTION: Basic log set of functions. Allow at the moment to display
'                 messages to the console or as msgbox
' PUBLIC METHODS:
'     . critical, error, waring, info, debug  -- output log message of the
'                                                corresponding level
' -----------------------------------------------------------------------------
Class Logger
    Private LogLevel
    Public LogToUser

    Private Sub Class_Initialize()
        LogLevel = LOG_ERROR
        LogToUser = True
    End Sub

    Public Property Let LogLvl(lvl)
        'We swicth to console display if we are going to issue a lot of
        'message for better readability
        If (lvl >= LOG_VERBOSE) AND LogToUser Then
            ShowLogConsole()
        End If
        LogLevel = lvl
    End Property

    Private Sub ShowLogConsole()
        'TODO: is there a better way to send output to console?
        If Instr(WScriptInterpreter, "wscript.exe")>0 Then
            WshShell.Run "%COMSPEC% /c cscript.exe //nologo "&WScriptCommandLine()&" & pause"
            WScript.Quit(0)
        End If
    End Sub

    Private Sub LogToConsole(msg)
        If LogToUser Then
            WScript.Echo msg
        End If
    End Sub

    Private Sub message(lvl, msg)
        If lvl <= LogLevel Then
            LogToConsole msg
        End If
    End Sub

    Public Sub debug(msg)
        message LOG_DEBUG, "DEBUG    -- "&msg
    End Sub

    Public Sub verbose(msg)
        message LOG_VERBOSE, "VERBOSE  -- "&msg
    End Sub

    Public Sub info(msg)
        message LOG_INFO, "INFO     -- "&msg
    End Sub

    Public Sub warning(msg)
        message LOG_WARNING, "WARNING  -- "&msg
    End Sub

    Public Sub error(msg)
        message LOG_ERROR, "ERROR    -- "&msg
    End Sub

    Public Sub critical(msg)
        message LOG_CRITICAL, "CRITICAL -- "&msg
    End Sub
End Class
'End Class Logger ------------------------------------------------------------

Private Function WScriptInterpreter()
    WScriptInterpreter = LCase(WScript.FullName)
End Function

Private Function WScriptCommandLine()
    cmdline = Chr(34) & WScript.ScriptFullName & Chr(34)
    For Each arg in WScript.Arguments
        cmdline = cmdline & " " & arg
    Next
    WScriptCommandLine = cmdline
End Function

' =============================================================================
'  DESCRIPTION: Simple helpers to manipulate the command line
' =============================================================================

'---+ Parse command line Arguments ---------------------------------------
For Each arg in WScript.Arguments
    LauncherArgs = AddCmdLine(LauncherArgs, SanitizeCmdLineArg(arg))
Next

' -----------------------------------------------------------------------------
'       NAME: AddCmdLine
' DESCIPTION: concatanate two parts of a command line
'    PARAM 1: first part of the command line
'    PARAM 2: second part of eth command line
'     RETURN: 1st part + second part
' -----------------------------------------------------------------------------
Public Function AddCmdLine(CLArgs, AddCLArgs)
    If CLArgs = "" Then
        AddCmdLine = AddCLArgs
    End If
    If AddCLArgs = "" Then
        AddCmdLine = CLArgs
    End If
    AddCmdLine = CLArgs & " " & AddCLArgs
End Function 'AddCmdLine -------------------------------------------------------


' -----------------------------------------------------------------------------
'       NAME: MergeCmdLine
' DESCIPTION: Add a command line option only if not already present
'    PARAM 1: Array name of the option names to add. Ex: ("-p", "--profile")
'    PARAM 2: value of the option to add
'    PARAM 3: current command line
'     RETURN: optionName + option value + commandline
' -----------------------------------------------------------------------------
Public Function MergeCmdLine(OptionName, OptionValue, CLArgs)
    newCmdLine = OptionName(0) & OptionValue
    For Each opt in OptionName
        If InStr(CLArgs, opt) > 0 Then
            LogDebug "Command Line Option "&opt&" is already set. Don't add it again"
            MergeCmdLine = CLArgs
        End If
    Next
    MergeCmdLine = AddCmdLine(newCmdLine, CLArgs)
End Function 'MergeCmdLine -------------------------------------------------


' -----------------------------------------------------------------------------
'       NAME: SanitizeCmdLineArg
' DESCIPTION: Add additional " to take care of arguments with space that can
'             confuse WShell.Run
'    PARAM 1: argument to sanitize
'     RETURN: sanitized argument
'       TODO: take care also of additional cases than space according to:
'             http://blogs.msdn.com/b/twistylittlepassagesallalike/archive/2011/04/23/everyone-quotes-arguments-the-wrong-way.aspx?Redirected=true
' -----------------------------------------------------------------------------
Public Function SanitizeCmdLineArg(arg)
    If InStr(arg, " ") <> 0 Then
        SanitizeCmdLineArg = Chr(34) & Chr(34) & arg & Chr(34) & Chr(34)
    Else
        SanitizeCmdLineArg = arg
    End If
End Function 'SanitizeCmdLineArg -----------------------------------------------

' =============================================================================
'  DESCRIPTION: modify environment and PATH
' =============================================================================

Set EnvVar = WshShell.Environment("Process")

' -----------------------------------------------------------------------------
'       NAME: SetEnv
' DESCIPRION: define an environment variable
'    PARAM 1: name of the variable
'    PARAM 2: value
' -----------------------------------------------------------------------------
Public Sub SetEnv(VarName, VarValue)
    AddTaskStart "SetEnv", Array(VarName,VarValue)
End Sub

Private Sub SetEnv_start(VarName, VarValue)
    EnvVar(VarName) = VarValue
    LogVerbose "Set environment variable "&VarName&"="&EnvVar(VarName)
End Sub
'End of Macro SetEnv ----------------------------------------------------------


' -----------------------------------------------------------------------------
'       NAME: AddToPATH
' DESCIPRION: Add a path to PATH
'    PARAM 1: path to add
' -----------------------------------------------------------------------------
Public Sub AddToPATH(path)
    AddTaskStart "AddToPATH", Array(path)
End Sub

Private Sub AddToPATH_start(path)
    If Instr(WshShell.ExpandEnvironmentStrings("%PATH%"), path) = 0 Then
        If EnvVar("PATH")="" Then
            EnvVar("PATH") = path
        Else
            EnvVar("PATH") = path&";"&EnvVar("PATH")
        End If
        LogVerbose "Add "&path&" to PATH -> PATH="&EnvVar("PATH")
    Else
        LogVerbose "Path "&path&" is already in PATH"
    End If
End Sub
'End Macro AddToPATH -----------------------------------------------------------

' =============================================================================
'  DESCRIPTION: create links
' =============================================================================
' TODO: [link_start] behavior if target already exists


' -----------------------------------------------------------------------------
'        NAME: Link
' DESCRIPTION: Link source to dest:
'             - If source is a folder, create a NTFS junction,
'             - If a source is a file, create a shortcut
'             - If dest is a drive letter, create a subst mount point
'     DEPENDS: junction.exe from sysinternal. junction.exe should be in PATH
'     PARAM 1: source, either a folder or a file
'     PARAM 2: destination.
' -----------------------------------------------------------------------------
Public Sub Link(source, target)
    AddTaskStart "link", Array(source, target)
End Sub

Private Function link_resID(source, target)
    link_resID = Array("link", source, target)
End Function

Private Sub link_start(source, target)
    If AcquireResource(link_resID(source, target)) Then
        If Right(target,1) = ":" Then
            LogVerbose "Create subst from "&source&" to "&target
            WshShell.Run "subst.exe """&target&""" """&source&"\""", RUN_HIDDEN, WAIT_FOR_ME

        ElseIf FSO.FolderExists(source) Then
            LogVerbose "Create junction from "&source&" to "&target
            WshShell.Run "junction.exe """&target&""" """&source&"""", RUN_HIDDEN, WAIT_FOR_ME

        ElseIf FSO.FileExists(source) Then
            LogVerbose "Create shortcut from "&source&" to "&target
            target = target & ".lnk"
            CreateShortcut target, source, ""

        Else
            TaskError "Link "&source&" to "&target&": "&source&" does not exist."
            ReleaseResource(link_resID(source, target))
            Exit Sub
        End If
    Else
        LogVerbose target&" was linked to "&source&" by another launcher"
    End If
    AddTaskStop "link", Array(source, target)
End Sub

Private Sub link_stop(source, target)
    If ReleaseResource(link_resID(source, target)) Then
        If Right(target,1) = ":" Then
            LogVerbose "Delete subst from "&source&" to "&target
            WshShell.Run "subst.exe """&target&""" /D", RUN_HIDDEN, WAIT_FOR_ME

        ElseIf FSO.FolderExists(target) Then
            LogVerbose "Delete junction from "&source&" to "&target
            WshShell.Run "junction.exe -d """&target&"""", RUN_HIDDEN, WAIT_FOR_ME

        ElseIf FSO.FileExists(target) Then
            LogVerbose "Delete shortcut from "&source&" to "&target
            FSO.GetFile(target).Delete(True)
        End If
    Else
        LogVerbose target&" is used by another launcher. Don't remove it"
    End If
End Sub
' End Macro Link --------------------------------------------------------------


' -----------------------------------------------------------------------------
'        NAME: Shortcut
' DESCRIPTION: Create a shortcut
'     PARAM 1: source, either a folder or a file
'     PARAM 2: destination.
'     PARAM 3: additional arguments to pass to the prog
' -----------------------------------------------------------------------------
Public Sub MakeShortcut(source, target, arguments)
    AddTaskStart "MakeShortcut", Array(source, target, arguments)
End Sub

Private Function MakeShortcut_resID(source, target)
    MakeShortcut_resID = Array("MakeShortcut", source, target)
End Function

Private Sub MakeShortcut_start(source, target, arguments)
    If AcquireResource(MakeShortcut_resID(source,target)) Then
        LogVerbose "Create shortcut from "&source&" to "&target
        CreateShortcut target&".lnk", source, arguments
    Else
        LogVerbose target&" was linked to "&source&" by another launcher"
    End If
    AddTaskStop "MakeShortcut", Array(source, target)
End Sub

Private Sub MakeShortcut_stop(source, target)
    If ReleaseResource(MakeShortcut_resID(source,target)) Then
        LogVerbose "Delete shortcut from "&target&" to "&source
        FSO.GetFile(target&".lnk").Delete(True)
    Else
        LogVerbose target&" is used by another launcher. Don't remove it"
    End If
End Sub
' End Macro Shortcut -----------------------------------------------------------


' -----------------------------------------------------------------------------
'        NAME: AddToDesktop
' DESCRIPTION: Create a link available from the Desktop
'     PARAM 1: source, either a folder or a file
'     PARAM 2: additional arguments to pass to the prog
'     PARAM 3: shortcut name
' -----------------------------------------------------------------------------
Public Sub AddToDesktop(source, arguments, targetName)
    target = WshShell.SpecialFolders("Desktop") & "\" & targetName
    MakeShortcut source, target, arguments
End Sub 'AddToDesktop ---------------------------------------------------------

' -----------------------------------------------------------------------------
'        NAME: AddToSendTo
' DESCRIPTION: Create a link available from the 'Send To' right click menu
'     PARAM 1: source, either a folder or a file
'     PARAM 2: additional arguments to pass to the prog
'     PARAM 3: shortcut name
' -----------------------------------------------------------------------------
Public Sub AddToSendTo(source, arguments, targetName)
    target = WshShell.SpecialFolders("SendTo") & "\" & targetName
    MakeShortcut source, target, arguments
End Sub 'AddToSendTo ----------------------------------------------------------

Private Sub CreateShortcut(source, target, arguments)
    LogDebug "Create a shortcut from "&source&" to "&target
    set shortcut = WshShell.CreateShortcut(source)
    shortcut.TargetPath = target
    shortcut.Arguments = arguments
    shortcut.save
End Sub


' =============================================================================
'  DESCRIPTION: load an app2go script
' =============================================================================

' -----------------------------------------------------------------------------
'        NAME: LoadScript
' DESCRIPTION: load an app2go script from a file
'     PARAM 1: path to script absolute or relative to current dir
' -----------------------------------------------------------------------------
Public Sub LoadScript(scriptPath)
    scriptPath = FSO.GetAbsolutePathName(scriptPath)
    If FSO.FileExists(scriptPath) Then
        load_script scriptPath
    Else
        Die "Script "&scriptPath&" cannot be found."
    End If
End Sub 'LoadScript -----------------------------------------------------------

' -----------------------------------------------------------------------------
'        NAME: LoadScriptIfExists
' DESCRIPTION: load an app2go script from a file, doesn't die if file doesn't
'              exist
'     PARAM 1: path to script absolute or relative to current dir
' -----------------------------------------------------------------------------
Public Sub LoadScriptIfExists(scriptPath)
    scriptPath = FSO.GetAbsolutePathName(scriptPath)
    If FSO.FileExists(scriptPath) Then
        load_script scriptPath
    Else
        LogWarning "Script "&scriptPath&" cannot be found. Pass loading"
    End If
End Sub 'LoadScript -----------------------------------------------------------

Private Sub load_script(scriptPath)
    LogDebug "Load script "&scriptPath
  'Change the current directory to allow 'LoadScript' work with relative
  'path from within the script we are including
    currDir = WshShell.CurrentDirectory
    WshShell.CurrentDirectory = FSO.GetParentFolderName(scriptPath)
  'Source script content
    set script = FSO.OpenTextFile(scriptPath)
    scriptCode = script.readAll()
    script.close
    executeGlobal scriptCode
  'Restore current directory
    WshShell.CurrentDirectory = currDir
end sub


' =============================================================================
'  DESCRIPTION: add/remove/delete from registry
' =============================================================================
' TODO: Switch to using WMI instead of WshShell functions to access registry

' -----------------------------------------------------------------------------
'        NAME: MergeHiveFile
' DESCRIPTION: Merge a Hive reg file. A hive is a logical group of keys, subkeys,
'              and values in the registry that has a set of supporting files
'              containing backups of its data.
'     PARAM 1: Key to be set or modified
'     PARAM 2: Value of the key
' TODO: get RegParentKey from HiveFilePath
' -----------------------------------------------------------------------------
Public Sub MergeHiveFile(HiveFilePath, RegParentKey)
    AddTaskStart "MergeHiveFile", Array(HivefilePath, RegParentKey)
End Sub

Private Function MergeHiveFile_resID(HiveFilePath, RegParentKey)
    MergeHiveFile_resID = Array("MergeHiveFile", HiveFilePath, RegParentKey)
End Function

Private Sub MergeHiveFile_start(HivefilePath, RegParentKey)
    resID = MergeHiveFile_resID(HivefilePath, RegParentKey)
    If AcquireResource(resID) Then
        restoreHiveFileName = FSO.GetBaseName(HiveFilePath)&"-BACKUP.reg"
        restoreHiveFilePath = FSO.GetParentFolderName(RegFilePath)&"\"&restoreHiveFileName
        WshShell.Run "regedit.exe /E /S "&restoreHiveFilePath&" "&RegParentPath, RUN_HIDDEN, WAIT_FOR_ME
        SetResourceParam resID, restoreHiveFilePath
        WshShell.RegDelete RegParentKey
        WshShell.Run "regedit.exe /S "&HiveFilePath, RUN_HIDDEN, WAIT_FOR_ME
        LogVerbose "Merge "&HiveFilePath&" into the registry"
    Else
        LogVerbose HiveFilePath&" was already merged by another launcher"
        restoreHiveFilePath = GetResourceParam(resID)
    End If
    AddTaskStop "MergeHiveFile", Array(HiveFilePath, restoreHiveFilePath, RegParentKey)
End Sub

Private Sub MergeHiveFile_stop(HivefilePath, restoreHiveFilePath, RegParentKey)
    If ReleaseResource(MergeHiveFile_resID(HiveFilePath, RegParentKey)) Then
        LogVerbose "Save modification of "&RegParentKey&" to "&HiveFilePath
        WshShell.Run "regedit.exe /E /S "&HiveFilePath&" "&RegParentPath, RUN_HIDDEN, WAIT_FOR_ME
        LogVerbose "Restore "&RegParentKey&" to it's original state"
        WshShell.RegDelete RegParentKey
        WshShell.Run "regedit.exe /S "&restoreHiveFilePath, RUN_HIDDE, WAIT_FOR_ME
        FSO.DeleteFile(restoreHiveFilePath)
    Else
        LogVerbose HiveFilePath&" is used by another launcher. Don't restore it"
    End If
End Sub
' End Macro MergeHiveFile ------------------------------------------------------

' -----------------------------------------------------------------------------
'        NAME: SetRegKey
' DESCRIPTION: Define a registry key value and restore it afterwards
'     PARAM 1: Key to be set or modified
'     PARAM 2: Value of the key
' -----------------------------------------------------------------------------
Public Sub SetRegKey(KeyName, KeyValue)
    AddTaskStart "SetRegKey", Array(KeyName, KeyValue)
End Sub

Private Function SetRegKey_resID(KeyName, KeyValue)
    SetRegKey_resID = Array("SetRegKey", KeyName, KeyValue)
End Function

Private Sub SetRegKey_start(KeyName, KeyValue)
    resID = SetRegKey_resID(KeyName, KeyValue)
    If AcquireResource(resID) Then
        restoreValue = ReadRegKey(KeyName)
        SetResourceParam resID, restoreValue
        WshShell.RegWrite KeyName, KeyValue
        LogVerbose "Set registry key "&KeyName&" to "&ReadRegKey(KeyName)
    Else
        LogVerbose "Registry key "&KeyName&" was defined by another launcher to "&ReadRegKey(KeyName)
        restoreValue = GetResourceParam(resID)
    End If
    AddTaskStop "SetRegKey", Array(KeyName, KeyValue, restoreValue)
End Sub

Private Sub SetRegKey_stop(KeyName, KeyValue, restoreValue)
    If ReleaseResource(SetRegKey_resID(KeyName, KeyValue)) Then
        If restoreValue="" Then
            LogVerbose "Remove registry key "&KeyName
            WshShell.RegDelete KeyName
        Else
            LogVerbose "Restore registry key "&KeyName&" to "&restoreValue
            WshShell.RegWrite KeyName, restoreValue
        End If
    Else
        LogVerbose "Registry key "&KeyName&" is used by another launcher. Don't restore it"
    End If
End Sub
' End Macro SetRegKey ---------------------------------------------------------


'Isn't it a beautiful piece of code, just to read a value in the registry ?
'I *LOVE* microsoft way of doing things...
'I really should have miss something
Private Function GetRegKeyDontExistErrDesc()
    Const FakeKey = "HKEY_DONT_EXIST\"
    On Error Resume Next
    WshShell.RegRead FakeKey
    GetRegKeyDontExistErrDesc = Replace(Err.Description, FakeKey, "")
    Err.Clear
    On Error Goto 0
End Function
RegKeyDontExists = GetRegKeyDontExistErrDesc()

Private Function ReadRegKey(KeyToRead)
    KeyName = KeyToRead
    If Not Right(KeyName, 1)="\" Then
        KeyName = KeyName & "\"
    End If
    On Error Resume Next
    RegReadKey = WshShell.RegRead(KeyName)
    If Replace(Err.Description, KeyName, "")=RegKeyDontExists Then
        LogDebug KeyName&" does not exist"
        RegReadKey = ""
        Err.Clear
    End If
    On Error Goto 0
End Function


' =============================================================================
'  DESCRIPTION: helpers to access removable drive
' =============================================================================

' -----------------------------------------------------------------------------
'        NAME: GetDriveByVolumeName
' DESCRIPTION: Get the drive name (H:, P:,...) of a disk given its volum name
'     PARAM 1: VolumeName to search for
'      OUTPUT: Drive Name or empty string
' -----------------------------------------------------------------------------
Public Function GetDriveByVolumeName(VolumeName)
    WMIQuery = "SELECT * from Win32_LogicalDisk WHERE VolumeName =""" & VolumeName & """"
    Set Drives = WMIService.ExecQuery(WMIQuery,,48)
    For Each drive in Drives
        LogDebug "Found that drive named "&VolumeName&" is known as "&drive.DeviceID
        GetDriveByVolumeName = drive.DeviceID
        Exit Function
    Next
    LogWarning "No Drive found whose name is " & VolumeName
End Function 'GetDriveByVolumeName --------------------------------------------


' -----------------------------------------------------------------------------
'        NAME: GetPhysicalDrive
' DESCRIPTION: Get the physical drive Id of a disk given its volume name
'     PARAM 1: Drive Letter of the disk to search physical name for
'      OUTPUT: Physical Id or empty string
' -----------------------------------------------------------------------------
Public Function GetPhysicalDrive(DriveLetter)
    WMIQuery = "ASSOCIATORS OF {Win32_LogicalDisk.DeviceID=""" & DriveLetter & """}" _
             & " WHERE AssocClass = Win32_LogicalDiskToPartition"
    Set Partitions = WMIService.ExecQuery(WMIQuery,,48)
    For Each part in Partitions
        PartID = part.DeviceID
    Next
    If PartID = "" Then
        TaskError "No partition found whose drice letter is " & DriveLetter
        Exit Function
    End If

    WMIQuery = "ASSOCIATORS OF {Win32_DiskPartition.DeviceID=""" & PartID & """}" _
             & " WHERE AssocClass = Win32_DiskDriveToDiskPartition"
   Set PhysicalDrives = WMIService.ExecQuery(WMIQuery,,48)
   For Each drive in PhysicalDrives
       LogDebug "Found that drive "&DriveLetter&" is known as "&drive.DeviceID
       GetPhysicalDrive = drive.DeviceID
       Exit Function
   Next
   LogWarning "No partition found whose drice letter is " & DriveLetter
End Function 'GetPhysicalDrive -------------------------------------------------


' =============================================================================
'  DESCRIPTION: add/remove/delete from registry
' =============================================================================

' -----------------------------------------------------------------------------
'        NAME: FixDriveLetter
' DESCRIPTION: Replace %LauncherDrive% with the drive letter from which the prog
'              is launched
'     PARAM 1: File to modify
' -----------------------------------------------------------------------------
Public Sub FixDriveLetter(FilePath)
    ReplaceInFile FilePath, "%LauncherDrive%", LauncherDrive
End Sub 'FixDriveLetter -------------------------------------------------------

' -----------------------------------------------------------------------------
'        NAME: FixUserFolders
' DESCRIPTION: Replace in a text file any reference to user folders by their
'              actual value. In that order:
'              - %DocFolder% by the folder name that contains the user documents
'              - %RootFolder% by the folder name that contains the App2go platform
'              - %LauncherDrive% by the drive letter that contains the launcher
'     PARAM 1: File to modify
' -----------------------------------------------------------------------------
Public Sub FixUserFolders(FilePath)
    If DocFolder <> "" Then
        ReplaceInFile FilePath, "%DocFolder%", DocFolder
    End If
    If RootFolder <> "" Then
        ReplaceInFile FilePath, "%RootFolder%", RootFolder
    End If
    ReplaceInFile FilePath, "%LauncherDrive%", LauncherDrive
End Sub 'FixUserFolders -------------------------------------------------------


' -----------------------------------------------------------------------------
'        NAME: ReplaceInFile
' DESCRIPTION: Replace a string in a text file
'     PARAM 1: File to modify
'     PARAM 2: Value to be replaced
'     PARAM 3: Replacement value
' -----------------------------------------------------------------------------
Public Sub ReplaceInFile(FilePath, ToReplace, ReplaceBy)
    AddTaskStart "ReplaceInFile", Array(FilePath, ToReplace, ReplaceBy)
End Sub

Private Function ReplaceInFile_resID(FilePath, ToReplace, ReplaceBy)
    ReplaceInFile_resID = Array("ReplaceInFile",FilePath, ToReplace, ReplaceBy)
End Function

Private Sub ReplaceInFile_start(FilePath, ToReplace, ReplaceBy)
    If AcquireResource(ReplaceInFile_resID(FilePath, ToReplace, ReplaceBy)) Then
        ReplaceStringInFile FilePath, ToReplace, ReplaceBy
        LogVerbose "Replace "&ToReplace&" by "&ReplaceBy&" in "&FilePath
    Else
        LogVerbose "Replacement of "&ToReplace&" by "&ReplaceBy&" in "&FilePath&" was done by another launcher"
    End If
    AddTaskStop "ReplaceInFile", Array(FilePath, ToReplace, ReplaceBy)
End Sub

Private Sub ReplaceInFile_stop(FilePath, ToReplace, ReplaceBy)
    If ReleaseResource(ReplaceInFile_resID(FilePath, ToReplace, ReplaceBy)) Then
        ReplaceStringInFile FilePath, ReplaceBy, ToReplace
        LogVerbose "Replace "&ReplaceBy&" by "&ToReplace&" in "&FilePath
    Else
        LogVerbose "File "&FilePath&" is used by another launcher. Don't restore it"
    End If
End Sub
' End Macro ReplaceInFile ------------------------------------------------------

Private Sub ReplaceStringInFile(FilePath, OldText, NewText)
    Const ForReading = 1
    Const ForWriting = 2
    LogDebug "Replace "&OldText&" by "&NewText&" in "&FilePath
  'Fail gracefully if file does not exists
    If Not FSO.FileExists(FilePath) Then
        LogWarning "File "&FilePath&" does not exist. Cannot replace "&OldText&" by "&NewText
        Exit Sub
    End If
  'Read and replace
    Set file = FSO.OpenTextFile(FilePath, ForReading)
    text = File.ReadAll
    file.Close
    newText = Replace(text, OldText, NewText)
   'Save new text
    Set file = FSO.OpenTextFile(FilePath, ForWriting)
    file.WriteLine newText
    file.Close
End Sub


' =============================================================================
'  DESCRIPTION: Run commands/apps
' =============================================================================

'---+ Nice Constants ----------------------------------------------------------
Const WAIT_FOR_ME = "True"
Const DONT_WAIT_FOR_ME = "False"
Const RUN_HIDDEN = 0
Const RUN_NORMAL = 1
Const RUN_MINIMIZED = 2
Const RUN_MAXIMIZED = 3

' -----------------------------------------------------------------------------
'          NAME: Run
'   DESCRIPTION: Execute a command
'       PARAM 1: program to execute
'       PARAM 2: program arguments
'    PARAM 3, 4: same than WshShell.Run WindowStyle and WaitOnReturn
'   TODO: use only spawn_proc instead of WshRun
'   TODO: get directly a process object instead of a pID for run_stop
'   TODO: share more code with run_exit and run_start
' -----------------------------------------------------------------------------
Public Sub Run(cmd, arg, WindowStyle, WaitOnReturn)
    AddTaskStart "run", Array(cmd, arg, WindowStyle, WaitOnReturn)
End Sub

Private Sub run_start(cmd, arg, WindowStyle, WaitOnReturn)
    cmdLine = build_command_line(cmd, arg)
    If WaitOnReturn Then
        LogVerbose "Run and wait for "&cmdLine
        exitCode = WshShell.Run(cmdLine, WindowStyle, WaitOnReturn)
        If exitCode <> 0 Then
            TaskError cmd&" failed to run with exit code "&exitCode
        Else
            LogDebug "Successfully run "&cmdLine
        End If
    Else
        out = spawn_proc(cmdLine, WindowStyle)
        If out(0) <> 0 Then 'exitcode
            TaskError "Fail to spawn "&cmdLine& "with exit code "&out(0)
        Else
            LogDebug "Successfully spawn "&cmdline
            AddTaskStop "run", Array(out(1))
        End If
    End If
End Sub

Private Sub run_stop(pid)
   WMIQuery = "SELECT * FROM Win32_Process WHERE ProcessId="""&pid&""""
    Set RunningProcesses = WMIService.ExecQuery(WMIQuery,,48)
    For Each proc in RunningProcesses
        LogVerbose "Killing: "&proc.CommandLine
        proc.Terminate
    Next
End Sub
'End Macro Run -----------------------------------------------------------------


' -----------------------------------------------------------------------------
'          NAME: RunOnExit
'   DESCRIPTION: Execute a command only when the launcher exit
'       PARAM 1: program to execute
'       PARAM 2: program arguments
'    PARAM 3, 4: same than WshShell.Run WindowStyle and WaitOnReturn
' -----------------------------------------------------------------------------
Public Sub RunOnExit(cmd, arg, WindowStyle, WaitOnReturn)
    AddTaskOnExit "Run", Array(cmd, arg, WindowStyle, WaitOnReturn)
End Sub

Private Sub Run_exit(cmd, arg, WindowStyle, WaitOnReturn)
    cmdLine = build_command_line(cmd, arg)
    If WaitOnReturn Then
        LogVerbose "Run and wait for "&cmdLine
        exitCode = WshShell.Run(cmdLine, WindowStyle, WaitOnReturn)
        If exitCode <> 0 Then
            TaskError cmd&" failed to run with exit code "&exitCode
        Else
            LogDebug "Successfully run "&cmdLine
        End If
    Else
        out = spawn_proc(cmdLine, WindowStyle)
        If out(0) <> 0 Then 'exitcode
            TaskError "Fail to spawn "&cmdLine& "with exit code "&out(0)
        Else
            LogDebug "Successfully spawn "&cmdline
        End If
    End If
End Sub
'End Macro RunOnExit -----------------------------------------------------------


Private Function build_command_line(cmd, arg)
    If arg <> "" Then
        build_command_line =  Chr(34) & cmd & Chr(34) & " " & arg
    Else
        build_command_line = Chr(34) & cmd & Chr(34)
    End If
End Function


Private Function spawn_proc(cmd, WindowStyle)
    Set ProcConfig = WMIService.Get("Win32_ProcessStartup").SpawnInstance_
    ProcConfig.ShowWindow = WindowStyle
    exitCode = WMIService.Get("Win32_Process").Create(cmd, Null, ProcConfig, ProcID)
    spawn_proc = Array(exitCode, ProcID)
End Function

' =============================================================================
'  DESCRIPTION: run a service shared between several launchers
' =============================================================================

' -----------------------------------------------------------------------------
'          NAME: RunService
'   DESCRIPTION: Execute a command as a shared 'service' for all lauchers
'       PARAM 1: program to execute
'       PARAM 2: program arguments
'       PARAM 3: same than WshShell.Run WindowStyle
' -----------------------------------------------------------------------------
Public Sub RunService(cmd, arg, WindowStyle)
    AddTaskStart "RunService", Array(cmd, arg, WindowStyle)
End Sub

Private Function RunService_resID(cmd, arg)
    RunService_resID = Array("RunService", cmd, arg)
End Function

Private Sub RunService_start(cmd, arg, WindowStyle)
    cmdLine = build_command_line(cmd, arg)
    resID = RunService_resID(cmd, arg)
    If AcquireResource(resID) Then
        If is_running(cmd, arg) > 0 Then
            LogVerbose cmd&" is already running but no launcher seems to reclaim it"
            ReleaseResource resID
        Else
            out = spawn_proc(cmdLine, WindowStyle)
            exitCode = out(0)
            pid = out(1)
            SetResourceParam resID, pid
            AddTaskOnExit "RunService", Array(cmdLine, pid)
            If exitCode <> 0 Then
                TaskError cmd&" failed to run with exit code "&exitCode
            Else
                LogVerbose "Successfully run service "&cmd
            End If
        End If
    Else
        servicePID = GetResourceParam(resID)
        AddTaskStop "RunService", Array(cmd, arg, ServicePID)
        LogVerbose cmd&" is already launched as a shared service (pid:"&ServicePID&")"
    End If
End Sub

Private Sub RunService_stop(cmd, arg, pid)
    cmdLine = build_command_line(cmd, arg)
    If ReleaseResource(RunService_resID(cmd, arg)) Then
        Run_stop pid
    Else
        LogVerbose cmd&" is used by another launcher. Don't kill it"
    End If
End Sub
' End Macro RunService --------------------------------------------------------


Private Function is_running(cmd, arg)
    'TODO: Look for program full path (use ExecutablePath instead of Name)?
    'TODO: Check if it's working with cmd with space
    ProcName = FSO.GetFileName(cmd) 'TODO: sould we use quote?
    CmdLine = "%"&join_str(ProcName, arg, "%") 'in WQL format for LIKE operator
    LogDebug "Check how many process "&cmd&" with arg "&arg&" are running"
    WMIQuery = "SELECT * FROM Win32_Process WHERE Name="""&ProcName&"""" _
             & " AND CommandLine LIKE """&CmdLine&""""
    Set RunningProcesses = WMIService.ExecQuery(WMIQuery,,48)
    'TODO: why RunningProcesses.Count doesn't work?
    For Each proc in RunningProcesses
        LogDebug "Running: "&proc.CommandLine
        procCount = procCount + 1
    Next
    is_running = (procCount > 0)
    LogDebug cmd&" is running : "&procCount&" times"
End Function
